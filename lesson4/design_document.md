# Design Document
## 第4週目　宿題

### 宿題1
- BFS用いて、あるノードまでの行き方が見つかったら、その行き方を辞書式のpathsにkey = index, value = 行き方として保存していった
- このpathsがそのノードが既に探索済みかを記憶する役割も果たすことにメリットがあると思った

### 宿題2
- 計算量がO(N^2 * 収束までの計算の繰り返し回数)となり、莫大な量になってしまった
- page_ranks_are_fixed(), calculate_page_ranks(), get_index_of_highest_ranks() などの関数を用い、なるべくモジュールするようにしたつもりだが、相変わらずあまり上手くできなかった
- 計算量を減らすためのアイディアとして思いついたのが、収束したと判断するための条件を緩めることである
- 実際、始めのページランクの計算後から最もページランクの高いページは変わっていなかった
- 最もページランクの高いページを求めるだけならば、ページランクが収束するまで計算する必要はないのではないかと思った
- しかし、上の論理を証明することができなかったので、愚直にページランクを細かく計算した

### 宿題3
- 最短経路を求めたときに使った経路（エッジ）を削除し次々と他の経路を求めていき、どの程度のエッジを削除すればノード間の経路がなくなるかを調べた
- 結果、「渋谷」から「パレートの法則」までは17回の経路を求め68のエッジを消してはじめて、「渋谷」から「パレートの法則」までの経路がなくなった
- また、この関数を実装しているときはエッジを消していくことで最終的に長い経路が表れるのではないかと考えていたが、結果的に最後に現れた経路は「渋谷」「1907年」「コンピュータ」「プログラミング用語_(分野別)」「80-20の法則」「パレートの法則」という6つのエッジを通過した経路だった
- 可能性としてはこの時点で「渋谷」から出るエッジか「パレートの法則」に入るエッジのどちらかが全て消えてしまったのかもしれない